import type { PhotoProcessingResult } from "@photobrain/image-processing";
import { eq } from "drizzle-orm";
import { db, photoExif, photoPhash, photos } from "@/db";

export interface SavePhotoResult {
	id: number;
	path: string;
	name: string;
	size: number;
	createdAt: Date;
	modifiedAt: Date;
	width: number | null;
	height: number | null;
	mimeType: string | null;
	isRaw: boolean;
	rawFormat: string | null;
	rawStatus: string | null;
	exif: {
		cameraMake?: string | null;
		cameraModel?: string | null;
		lensMake?: string | null;
		lensModel?: string | null;
		focalLength?: number | null;
		iso?: number | null;
		aperture?: string | null;
		shutterSpeed?: string | null;
		exposureBias?: string | null;
		dateTaken?: string | null;
		gpsLatitude?: string | null;
		gpsLongitude?: string | null;
		gpsAltitude?: string | null;
	} | null;
}

/**
 * Save a photo from Rust's PhotoProcessingResult directly to the database.
 */
export async function saveRustPhotoToDb(
	result: PhotoProcessingResult,
): Promise<SavePhotoResult> {
	// Check if photo already exists
	const existing = await db
		.select({ id: photos.id })
		.from(photos)
		.where(eq(photos.path, result.path))
		.get();

	let photoId: number;

	if (existing) {
		// Update existing photo
		await db
			.update(photos)
			.set({
				name: result.name,
				size: result.size,
				modifiedAt: new Date(result.modifiedAt),
				width: result.width ?? null,
				height: result.height ?? null,
				mimeType: result.mimeType ?? null,
				isRaw: result.isRaw,
				rawFormat: result.rawFormat ?? null,
				rawStatus: result.rawStatus ?? null,
				rawError: result.rawError ?? null,
				thumbnailStatus: "completed",
				embeddingStatus: "pending", // Re-generate embedding on rescan
				phashStatus: result.phash ? "completed" : "failed",
			})
			.where(eq(photos.id, existing.id));
		photoId = existing.id;
	} else {
		// Insert new photo - phash generated by Rust, embedding deferred to batch job
		const inserted = await db
			.insert(photos)
			.values({
				path: result.path,
				name: result.name,
				size: result.size,
				createdAt: new Date(result.createdAt),
				modifiedAt: new Date(result.modifiedAt),
				width: result.width ?? null,
				height: result.height ?? null,
				mimeType: result.mimeType ?? null,
				isRaw: result.isRaw,
				rawFormat: result.rawFormat ?? null,
				rawStatus: result.rawStatus ?? null,
				rawError: result.rawError ?? null,
				thumbnailStatus: "completed",
				embeddingStatus: "pending", // Will be generated in batch after scan
				phashStatus: result.phash ? "completed" : "failed",
			})
			.returning({ id: photos.id });
		photoId = inserted[0].id;
	}

	// Save EXIF data if available
	if (result.exif) {
		// Delete existing EXIF data
		await db.delete(photoExif).where(eq(photoExif.photoId, photoId));

		// Insert new EXIF data
		await db.insert(photoExif).values({
			photoId,
			cameraMake: result.exif.cameraMake ?? null,
			cameraModel: result.exif.cameraModel ?? null,
			lensMake: result.exif.lensMake ?? null,
			lensModel: result.exif.lensModel ?? null,
			focalLength: result.exif.focalLength ?? null,
			iso: result.exif.iso ?? null,
			aperture: result.exif.aperture ?? null,
			shutterSpeed: result.exif.shutterSpeed ?? null,
			exposureBias: result.exif.exposureBias ?? null,
			dateTaken: result.exif.dateTaken ?? null,
			gpsLatitude: result.exif.gpsLatitude ?? null,
			gpsLongitude: result.exif.gpsLongitude ?? null,
			gpsAltitude: result.exif.gpsAltitude ?? null,
		});
	}

	// Save phash (already generated by Rust)
	if (result.phash) {
		await db.delete(photoPhash).where(eq(photoPhash.photoId, photoId));
		await db.insert(photoPhash).values({
			photoId,
			hash: result.phash,
			algorithm: "double_gradient_8x8",
			createdAt: new Date(),
		});
	}

	// Note: CLIP embeddings are now generated in a batch job after scan completes
	// This makes the initial scan ~3x faster

	// Return full photo data so it can be sent to the client
	return {
		id: photoId,
		path: result.path,
		name: result.name,
		size: result.size,
		createdAt: new Date(result.createdAt),
		modifiedAt: new Date(result.modifiedAt),
		width: result.width ?? null,
		height: result.height ?? null,
		mimeType: result.mimeType ?? null,
		isRaw: result.isRaw,
		rawFormat: result.rawFormat ?? null,
		rawStatus: result.isRaw ? "converted" : null,
		exif: result.exif
			? {
					cameraMake: result.exif.cameraMake ?? null,
					cameraModel: result.exif.cameraModel ?? null,
					lensMake: result.exif.lensMake ?? null,
					lensModel: result.exif.lensModel ?? null,
					focalLength: result.exif.focalLength ?? null,
					iso: result.exif.iso ?? null,
					aperture: result.exif.aperture ?? null,
					shutterSpeed: result.exif.shutterSpeed ?? null,
					exposureBias: result.exif.exposureBias ?? null,
					dateTaken: result.exif.dateTaken ?? null,
					gpsLatitude: result.exif.gpsLatitude ?? null,
					gpsLongitude: result.exif.gpsLongitude ?? null,
					gpsAltitude: result.exif.gpsAltitude ?? null,
				}
			: null,
	};
}
